# Backend Data Generation Improvements

## Overview
Based on user feedback, the snapshot minting flow has been improved so that the backend generates and returns ALL necessary data for both the contract call and the webhook. This ensures consistency, reduces frontend complexity, and minimizes potential errors.

## Key Improvements

### 1. Backend Generates processId
**Before:** Frontend generated processId  
**After:** Backend generates unique processId and returns it in GET response

**Benefit:** Ensures consistent format and uniqueness

### 2. Backend Fetches Next Snapshot ID
**Before:** Frontend estimated: `snapshots.length + 1`  
**After:** Backend calls `getNextSnapshotId()` on SnapshotNFT contract

**Benefit:** Accurate snapshot ID from contract, not an estimate

### 3. Backend Retrieves Block Number
**Before:** Frontend used `creationBlock || 0`  
**After:** Backend fetches current block number from provider

**Benefit:** Accurate block number at preparation time

### 4. Backend Looks Up Beneficiary Code
**Before:** Frontend accessed beneficiaryCodes array  
**After:** Backend queries beneficiary data from Distributor contract

**Benefit:** Single source of truth from contract, not frontend state

### 5. Backend Calculates Distribution
**Before:** Frontend calculated from snapshots state  
**After:** Backend fetches all seed snapshots and calculates precise distribution

**Benefit:** Accurate calculation based on contract data

## API Changes

### GET Endpoint Enhancement

**Endpoint:** `GET /api/write/snapshots/mint/:seedId?beneficiaryIndex=0`

**New Query Parameter:**
- `beneficiaryIndex` (optional): When provided, backend includes beneficiary-specific data

**Enhanced Response:**
```json
{
  "success": true,
  "data": {
    "contractAddress": "0x...",
    "functionName": "mintSnapshot",
    "args": {
      "seedId": 1,
      "beneficiaryIndex": 0,  // included when query param provided
      "royaltyRecipient": "0x..."
    },
    "value": "1000000000000000000",
    "valueEth": "1.0",
    "seedOwner": "0x...",
    
    // NEW: Backend-generated data
    "processId": "1234567890-abc123def",      // Generated by backend
    "snapshotId": 42,                          // From contract.getNextSnapshotId()
    "blockNumber": 1000001,                    // From provider.getBlockNumber()
    "beneficiaryCode": "01-GRG",              // From contract beneficiary data
    "beneficiaryDistribution": 25.5            // Calculated from contract snapshots
  }
}
```

## New Contract Service Methods

### 1. `getNextSnapshotId()`
```typescript
async getNextSnapshotId(): Promise<number>
```
Calls `SnapshotNFT.getNextSnapshotId()` to get the next global snapshot ID.

### 2. `getCurrentBlockNumber()`
```typescript
async getCurrentBlockNumber(): Promise<number>
```
Calls `provider.getBlockNumber()` to get current block.

## Frontend Workflow Changes

### Old Workflow
```javascript
// 1. Call GET endpoint
const response = await fetch(`/api/write/snapshots/mint/${seedId}`);
const data = await response.json();

// 2. Frontend generates its own data
const processId = `${Date.now()}-${Math.random()...}`;
const snapshotId = snapshots.length + 1;  // Estimate
const beneficiaryCode = beneficiaryCodes[beneficiaryIndex];
const distribution = calculateDistribution();  // Frontend logic

// 3. Call contract
const tx = await writeContract({
  args: [seedId, beneficiaryIndex, processId, address, royalty],
  value: snapshotPrice
});

// 4. Call webhook with frontend-generated data
await fetch('/api/snapshot-minted', {
  body: JSON.stringify({
    processId,  // Frontend-generated
    snapshotId, // Frontend-estimated
    beneficiaryCode,
    beneficiaryDistribution: distribution,
    // ... other data
  })
});
```

### New Workflow
```javascript
// 1. Call GET endpoint with beneficiaryIndex
const response = await fetch(
  `/api/write/snapshots/mint/${seedId}?beneficiaryIndex=${index}`
);
const data = await response.json();

// 2. Use ALL backend-provided data
const {
  processId,              // From backend
  snapshotId,             // From backend
  beneficiaryCode,        // From backend
  beneficiaryDistribution, // From backend
  blockNumber,            // From backend
  contractAddress,
  value,
  args
} = data.data;

// 3. Call contract with backend data
const tx = await writeContract({
  address: contractAddress,
  args: [
    args.seedId,
    args.beneficiaryIndex,
    processId,        // Use backend processId
    userAddress,      // Only value from frontend
    args.royaltyRecipient
  ],
  value: BigInt(value)
});

// 4. Call webhook - relay backend data back
await fetch('/api/snapshot-minted', {
  body: JSON.stringify({
    contractAddress,          // From backend
    seedId: args.seedId,      // From backend
    snapshotId,               // From backend
    beneficiaryCode,          // From backend
    beneficiaryDistribution,  // From backend
    processId,                // From backend (same value!)
    blockNumber,              // From backend
    creator: userAddress,     // From frontend
    txHash: tx,              // From transaction
    timestamp: Math.floor(Date.now() / 1000)
  })
});
```

## Benefits

### 1. Data Consistency
- processId is guaranteed to match between contract call and webhook
- No risk of frontend miscalculating distribution
- Snapshot ID is accurate from contract, not estimated

### 2. Single Source of Truth
- All contract data comes from contract queries
- No reliance on frontend state that might be stale
- Backend controls data format and generation

### 3. Reduced Frontend Complexity
- Frontend doesn't need to:
  - Generate unique IDs
  - Calculate distributions
  - Look up beneficiary codes
  - Estimate snapshot IDs
- Frontend simply relays backend data

### 4. Better Error Prevention
- No mismatch between processId in contract and webhook
- No incorrect snapshot IDs
- No miscalculated distributions
- All validations happen in one place (backend)

### 5. Easier Debugging
- Backend logs show generated processId
- Can trace exact data sent to frontend
- Webhook receives same data backend generated

## Migration Notes

### Environment Variables
- Update `.env`: `SNAP_FACTORY_ADDRESS` → `SNAPSHOT_FACTORY`
- Ensure `SNAPSHOT_NFT_ADDRESS` is set for `getNextSnapshotId()`

### Frontend Changes
1. Add `?beneficiaryIndex=X` query parameter to GET request
2. Store entire GET response data object
3. Use backend-provided processId (remove frontend generation)
4. Use backend-provided snapshotId (remove estimation logic)
5. Use backend-provided beneficiaryCode (remove array lookup)
6. Use backend-provided distribution (remove calculation)
7. In webhook, relay backend data instead of regenerating it

### Testing
```bash
# Test with beneficiary data
curl 'http://localhost:3001/api/write/snapshots/mint/1?beneficiaryIndex=0'

# Should return complete data including processId, snapshotId, etc.
```

## Architecture Benefits

```
┌────────────────────────────────────────────────────────┐
│                    OLD ARCHITECTURE                    │
├────────────────────────────────────────────────────────┤
│                                                        │
│  Backend → Partial Data → Frontend                     │
│                              ↓                         │
│                         Generate:                      │
│                         - processId                    │
│                         - snapshotId (estimate)        │
│                         - calculate distribution       │
│                              ↓                         │
│                         Contract Call                  │
│                              ↓                         │
│                         Webhook                        │
│                                                        │
│  ❌ Issues:                                            │
│  - Data mismatch risk                                  │
│  - Frontend complexity                                 │
│  - Estimation errors                                   │
│  - Multiple sources of truth                           │
│                                                        │
└────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────┐
│                    NEW ARCHITECTURE                    │
├────────────────────────────────────────────────────────┤
│                                                        │
│  Backend → Complete Data → Frontend                    │
│     ↓                          ↓                       │
│  Generates:              Uses Backend Data             │
│  - processId                   ↓                       │
│  - snapshotId (contract)  Contract Call               │
│  - beneficiary code            ↓                       │
│  - distribution           Relays Backend Data          │
│  - block number                ↓                       │
│                            Webhook                     │
│                                                        │
│  ✅ Benefits:                                          │
│  - Data consistency guaranteed                         │
│  - Frontend is simple relay                            │
│  - Contract data is accurate                           │
│  - Single source of truth                              │
│                                                        │
└────────────────────────────────────────────────────────┘
```

## Validation

The backend now serves as the authoritative source for all minting data:

1. **processId**: Guaranteed unique and consistent
2. **snapshotId**: Fetched from contract, not estimated
3. **beneficiaryCode**: Queried from Distributor contract
4. **beneficiaryDistribution**: Calculated from actual contract snapshots
5. **blockNumber**: Current block from provider

Frontend simply uses this data for the transaction and relays it back for the webhook.

## Summary

This improvement transforms the backend from a passive data provider to an active data generator and validator. The frontend's role is simplified to:
1. Request data with user selections (beneficiaryIndex)
2. Execute transaction with user's wallet (providing only the `to` address)
3. Relay backend data back to webhook with transaction details

This architecture ensures data integrity, reduces errors, and creates a clear separation of concerns between backend (data authority) and frontend (transaction executor).

